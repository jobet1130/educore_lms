name: EduCore LMS CI/CD Pipeline

permissions:
  contents: write
  security-events: write
  actions: read
  packages: write
  pull-requests: write
  issues: write

on:
  push:
    branches:
      - main
      - qa
      - stagingTest
      - staging
      - releaseTest
      - release
      - 'feature/*'
      - 'hotfix/*'
      - 'enhancement/*'
      - 'bugfix/*'
  pull_request:
    branches:
      - main
      - qa
      - staging
      - release
      - 'feature/*'
      - 'hotfix/*'
      - 'enhancement/*'
      - 'bugfix/*'
    types: [opened, synchronize, reopened]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Code Quality and Testing
  test:
    name: Code Quality & Tests
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_PASSWORD: test_password
          POSTGRES_USER: test_user
          POSTGRES_DB: test_educore_lms
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install flake8 black isort pytest-django coverage
    
    - name: Code formatting check (Black)
      run: black --check --diff .
    
    - name: Import sorting check (isort)
      run: isort --check-only --diff .
    
    - name: Lint with flake8
      run: |
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
    
    - name: Run Django tests
      env:
        DATABASE_URL: postgres://test_user:test_password@localhost:5432/test_educore_lms
        SECRET_KEY: test-secret-key-for-ci
        DEBUG: 0
      run: |
        python manage.py collectstatic --noinput
        coverage run --source='.' manage.py test
        coverage report --show-missing
        coverage xml
    
    - name: Upload coverage reports
      uses: codecov/codecov-action@v5
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella

  # Security Scanning
  security:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: test
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'
    
    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  # Build Docker Images
  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: [test, security]
    if: github.event_name == 'push'
    
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
      dockerhub-tag: ${{ steps.meta-dockerhub.outputs.tags }}
      dockerhub-digest: ${{ steps.build-dockerhub.outputs.digest }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
    
    - name: Extract metadata for GitHub Container Registry
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
    
    - name: Extract metadata for Docker Hub
      id: meta-dockerhub
      uses: docker/metadata-action@v5
      with:
        images: ${{ secrets.DOCKER_USERNAME }}/educore-lms
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
    
    - name: Build and push Docker image to GitHub Container Registry
      id: build
      uses: docker/build-push-action@v6
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
    
    - name: Build and push Docker image to Docker Hub
      id: build-dockerhub
      uses: docker/build-push-action@v6
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta-dockerhub.outputs.tags }}
        labels: ${{ steps.meta-dockerhub.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
    
    - name: Build Summary
      run: |
        echo "Docker images built and pushed successfully!"
        echo "GitHub Container Registry:"
        echo "  Tags: ${{ steps.meta.outputs.tags }}"
        echo "  Digest: ${{ steps.build.outputs.digest }}"
        echo "Docker Hub:"
        echo "  Tags: ${{ steps.meta-dockerhub.outputs.tags }}"
        echo "  Digest: ${{ steps.build-dockerhub.outputs.digest }}"
        echo "Images available on both registries"
  
  # Determine Environment and Docker Tag
  determine-environment:
    name: Determine Environment
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push'
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      docker_tag: ${{ steps.env.outputs.docker_tag }}
    
    steps:
    - name: Determine environment and docker tag
      id: env
      run: |
        # Sequential deployment flow: Development -> QA -> UAT -> Production
        if [[ "$BRANCH_NAME" == "release" ]]; then
          echo "environment=development" >> $GITHUB_OUTPUT
          echo "docker_tag=latest" >> $GITHUB_OUTPUT
        elif [[ "$BRANCH_NAME" == "main" ]]; then
          echo "environment=development" >> $GITHUB_OUTPUT
          echo "docker_tag=main" >> $GITHUB_OUTPUT
        elif [[ "$BRANCH_NAME" == "staging" || "$BRANCH_NAME" == "releaseTest" ]]; then
          echo "environment=development" >> $GITHUB_OUTPUT
          echo "docker_tag=uat" >> $GITHUB_OUTPUT
        elif [[ "$BRANCH_NAME" == "stagingTest" ]]; then
          echo "environment=development" >> $GITHUB_OUTPUT
          echo "docker_tag=qa" >> $GITHUB_OUTPUT
        elif [[ "$BRANCH_NAME" == "qa" ]]; then
          echo "environment=development" >> $GITHUB_OUTPUT
          echo "docker_tag=sandbox" >> $GITHUB_OUTPUT
        elif [[ "$BRANCH_NAME" == feature/* ]]; then
          echo "environment=development" >> $GITHUB_OUTPUT
          echo "docker_tag=feature-$(echo $BRANCH_NAME | sed 's/feature\///')" >> $GITHUB_OUTPUT
        elif [[ "$BRANCH_NAME" == hotfix/* ]]; then
          echo "environment=development" >> $GITHUB_OUTPUT
          echo "docker_tag=hotfix-$(echo $BRANCH_NAME | sed 's/hotfix\///')" >> $GITHUB_OUTPUT
        elif [[ "$BRANCH_NAME" == enhancement/* ]]; then
          echo "environment=development" >> $GITHUB_OUTPUT
          echo "docker_tag=enhancement-$(echo $BRANCH_NAME | sed 's/enhancement\///')" >> $GITHUB_OUTPUT
        elif [[ "$BRANCH_NAME" == bugfix/* ]]; then
          echo "environment=development" >> $GITHUB_OUTPUT
          echo "docker_tag=bugfix-$(echo $BRANCH_NAME | sed 's/bugfix\///')" >> $GITHUB_OUTPUT
        else
          echo "environment=development" >> $GITHUB_OUTPUT
          echo "docker_tag=dev" >> $GITHUB_OUTPUT
        fi
      env:
        BRANCH_NAME: ${{ github.ref_name }}

  # Deploy to Sandbox (disabled - not part of sequential flow)
  deploy-sandbox:
    name: Deploy to Sandbox
    runs-on: ubuntu-latest
    needs: [build, determine-environment]
    if: false  # Disabled: not part of Development -> QA -> UAT -> Production flow
    environment:
      name: sandbox
      url: http://localhost:8001/
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Install Docker Compose
      run: |
        sudo curl -L "https://github.com/docker/compose/releases/download/v2.24.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
        sudo chmod +x /usr/local/bin/docker-compose
        docker-compose --version
    
    - name: Pre-deployment Health Check
      run: |
        echo "Performing pre-deployment health check..."
        # Check if previous deployment is healthy
        curl -f http://localhost:8001/health/ || echo "Previous deployment not accessible"
    
    - name: Deploy to Sandbox
      run: |
        echo "Deploying to Sandbox environment..."
        echo "Using docker tag: ${{ needs.determine-environment.outputs.docker_tag }}"
        
        # Pull latest images
        docker-compose -f docker-compose.sandbox.yml pull
        
        # Stop existing containers
        docker-compose -f docker-compose.sandbox.yml down
        
        # Deploy new version
        export DOCKER_TAG=${{ needs.determine-environment.outputs.docker_tag }}
        docker-compose -f docker-compose.sandbox.yml up -d
        
        # Wait for containers to be ready
        sleep 30
    
    - name: Database Migration
      env:
        SECRET_KEY: django-insecure-ci-key-for-testing
        DATABASE_URL: postgres://postgres:postgres@localhost:5433/educore_lms
        ALLOWED_HOSTS: localhost,127.0.0.1
        DB_PASSWORD: postgres
      run: |
        echo "Running database migrations..."
        docker-compose -f docker-compose.sandbox.yml exec -T web python manage.py migrate --noinput
    
    - name: Collect Static Files
      run: |
        echo "Collecting static files..."
        docker-compose -f docker-compose.sandbox.yml exec -T web python manage.py collectstatic --noinput
    
    - name: Health Check
      run: |
        echo "Performing post-deployment health check..."
        for i in {1..10}; do
          if curl.exe -f http://localhost:8001/health/; then
            echo "Sandbox deployment successful!"
            exit 0
          fi
          echo "Attempt $i failed, retrying in 10 seconds..."
          sleep 10
        done
        echo "Health check failed after 10 attempts"
        exit 1
    
    - name: Deployment Notification
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "Sandbox deployment completed successfully"
          echo "URL: http://sandbox.educore-lms.com"
          echo "Tag: ${{ needs.determine-environment.outputs.docker_tag }}"
        else
          echo "Sandbox deployment failed"
        fi

  # Deploy to QA (after successful development deployment)
  deploy-qa:
    name: Deploy to QA
    runs-on: ubuntu-latest
    needs: [build, determine-environment, deploy-development]
    if: needs.deploy-development.result == 'success'
    environment:
      name: qa
      url: http://localhost:8002/
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Install Docker Compose
      run: |
        sudo curl -L "https://github.com/docker/compose/releases/download/v2.24.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
        sudo chmod +x /usr/local/bin/docker-compose
        docker-compose --version
    
    - name: Pre-deployment Health Check
      run: |
        echo "Performing pre-deployment health check..."
        # Check if previous deployment is healthy
        curl -f http://localhost:8002/health/ || echo "Previous deployment not accessible"

    - name: Create environment file
      run: |
        echo "Creating .env.qa for QA environment"
        
        # Create QA environment .env file
        {
          echo "DJANGO_SETTINGS_MODULE=educore_lms.settings.qa"
          echo "SECRET_KEY=${{ secrets.DJANGO_SECRET_KEY }}"
          echo "DATABASE_URL=${{ secrets.DATABASE_URL }}"
          echo "REDIS_URL=${{ secrets.REDIS_URL }}"
          echo "EMAIL_HOST_PASSWORD=${{ secrets.EMAIL_HOST_PASSWORD }}"
          echo "SENTRY_DSN=${{ secrets.SENTRY_DSN }}"
          echo "ENVIRONMENT=qa"
          echo "DOCKER_IMAGE_TAG=${{ needs.determine-environment.outputs.docker_tag }}"
          echo "DB_NAME=${{ secrets.DB_NAME }}"
          echo "DB_USER=${{ secrets.DB_USER }}"
          echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}"
          echo "DB_HOST=db"
          echo "DB_PORT=5432"
          echo "ALLOWED_HOSTS=${{ secrets.ALLOWED_HOSTS }}"
          echo "DEBUG=0"
          echo "DJANGO_LOG_LEVEL=INFO"
        } > .env.qa

    - name: Deploy to QA
      run: |
        echo "Deploying to QA environment..."
        echo "Using docker tag: ${{ needs.determine-environment.outputs.docker_tag }}"
        
        # Pull latest images
        docker-compose -f docker-compose.qa.yml pull
        
        # Stop existing containers
        docker-compose -f docker-compose.qa.yml down
        
        # Deploy new version
        export DOCKER_TAG=${{ needs.determine-environment.outputs.docker_tag }}
        docker-compose -f docker-compose.qa.yml up -d
        
        # Wait for containers to be ready
        sleep 30
    
    - name: Database Migration
      env:
        SECRET_KEY: django-insecure-ci-key-for-testing
        DATABASE_URL: postgres://postgres:postgres@localhost:5434/educore_lms
        ALLOWED_HOSTS: localhost,127.0.0.1
        DB_PASSWORD: postgres
      run: |
        echo "Running database migrations..."
        docker-compose -f docker-compose.qa.yml exec -T web python manage.py migrate --noinput
    
    - name: Collect Static Files
      run: |
        echo "Collecting static files..."
        docker-compose -f docker-compose.qa.yml exec -T web python manage.py collectstatic --noinput
    
    - name: Run Tests
      run: |
        echo "Running automated tests..."
        docker-compose -f docker-compose.qa.yml exec -T web python manage.py test --keepdb
    
    - name: Health Check
      run: |
        echo "Performing post-deployment health check..."
        for i in {1..10}; do
          if curl.exe -f http://localhost:8002/health/; then
            echo "QA deployment successful!"
            exit 0
          fi
          echo "Attempt $i failed, retrying in 10 seconds..."
          sleep 10
        done
        echo "Health check failed after 10 attempts"
        exit 1
    
    - name: Deployment Notification
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "QA deployment completed successfully"
          echo "URL: http://qa.educore-lms.com"
          echo "Tag: ${{ needs.determine-environment.outputs.docker_tag }}"
        else
          echo "QA deployment failed"
        fi

  # Deploy to UAT (after successful QA deployment)
  deploy-uat:
    name: Deploy to UAT
    runs-on: ubuntu-latest
    needs: [build, determine-environment, deploy-qa]
    if: needs.deploy-qa.result == 'success'
    environment:
      name: uat
      url: http://localhost:8003/
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Install Docker Compose
      run: |
        sudo curl -L "https://github.com/docker/compose/releases/download/v2.24.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
        sudo chmod +x /usr/local/bin/docker-compose
        docker-compose --version
    
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Pre-deployment Backup
      run: |
        echo "Creating pre-deployment backup..."
        # Create database backup
        docker-compose -f docker-compose.uat.yml exec -T -e PGPASSWORD="${DB_PASSWORD:-postgres}" db pg_dump -U "${DB_USER:-postgres}" -d "${DB_NAME:-educore_db}" > backup_$(date +%Y%m%d_%H%M%S).sql
        
        # Backup static files
        tar -czf static_backup_$(date +%Y%m%d_%H%M%S).tar.gz static/
    
    - name: Pre-deployment Health Check
      run: |
        echo "Performing pre-deployment health check..."
        curl -f http://localhost:8003/health/ || echo "Previous deployment not accessible"

    - name: Create environment file
      run: |
        echo "Creating .env.uat for UAT environment"
        
        # Create UAT environment .env file
        {
          echo "DJANGO_SETTINGS_MODULE=educore_lms.settings.uat"
          echo "SECRET_KEY=${{ secrets.DJANGO_SECRET_KEY }}"
          echo "DATABASE_URL=${{ secrets.DATABASE_URL }}"
          echo "REDIS_URL=${{ secrets.REDIS_URL }}"
          echo "EMAIL_HOST_PASSWORD=${{ secrets.EMAIL_HOST_PASSWORD }}"
          echo "SENTRY_DSN=${{ secrets.SENTRY_DSN }}"
          echo "ENVIRONMENT=uat"
          echo "DOCKER_IMAGE_TAG=${{ needs.determine-environment.outputs.docker_tag }}"
          echo "DB_NAME=${{ secrets.DB_NAME }}"
          echo "DB_USER=${{ secrets.DB_USER }}"
          echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}"
          echo "DB_HOST=db"
          echo "DB_PORT=5432"
          echo "ALLOWED_HOSTS=${{ secrets.ALLOWED_HOSTS }}"
          echo "DEBUG=0"
          echo "DJANGO_LOG_LEVEL=WARNING"
        } > .env.uat

    - name: Deploy to UAT
      run: |
        echo "Deploying to UAT environment..."
        echo "Using docker tag: uat"
        
        # Pull latest images
        docker-compose -f docker-compose.uat.yml pull
        
        # Stop existing containers gracefully
        docker-compose -f docker-compose.uat.yml stop
        
        # Deploy new version
        export DOCKER_TAG=uat
        docker-compose -f docker-compose.uat.yml up -d
        
        # Wait for containers to be ready
        sleep 90  # Increased from 45s to account for health check start period
        
        # Check container health before proceeding
        echo "Checking container health..."
        for i in {1..15}; do
          WEB_STATUS=$(docker-compose -f docker-compose.uat.yml ps web | grep -o "Up.*" || echo "Not running")
          DB_STATUS=$(docker-compose -f docker-compose.uat.yml ps db | grep -o "Up.*" || echo "Not running")
          
          echo "Web container: $WEB_STATUS"
          echo "DB container: $DB_STATUS"
          
          if echo "$WEB_STATUS" | grep -q "healthy" && echo "$DB_STATUS" | grep -q "healthy"; then
            echo "All containers are healthy and ready"
            break
          elif [ $i -eq 15 ]; then
            echo "âŒ Containers failed to become healthy after 15 attempts"
            docker-compose -f docker-compose.uat.yml logs
            exit 1
          else
            echo "â³ Waiting for containers to be healthy... ($i/15)"
            sleep 15
          fi
        done
    
    - name: Database Migration
      env:
        SECRET_KEY: django-insecure-ci-key-for-testing
        DATABASE_URL: postgres://postgres:postgres@localhost:5435/educore_lms
        ALLOWED_HOSTS: localhost,127.0.0.1
        DB_PASSWORD: postgres
      run: |
        # Wait for database to be ready
        echo "Checking database connectivity..."
        for i in {1..10}; do
          if docker-compose -f docker-compose.uat.yml exec -T db pg_isready -U postgres > /dev/null 2>&1; then
            echo "Database is ready"
            break
          else
            echo "Waiting for database to be ready... ($i/10)"
            sleep 5
          fi
        done
        
        # Ensure containers are healthy before migration
        echo "Validating container health before migration..."
        for i in {1..5}; do
          WEB_STATUS=$(docker-compose -f docker-compose.uat.yml ps web | grep -o "Up.*" || echo "Not running")
          DB_STATUS=$(docker-compose -f docker-compose.uat.yml ps db | grep -o "Up.*" || echo "Not running")
          
          if echo "$WEB_STATUS" | grep -q "healthy" && echo "$DB_STATUS" | grep -q "healthy"; then
            echo "âœ… Containers are healthy, proceeding with migration"
            break
          elif echo "$WEB_STATUS" | grep -q "restarting" || echo "$DB_STATUS" | grep -q "restarting"; then
            echo "âš ï¸ Container is restarting, waiting... ($i/5)"
            sleep 20
          elif [ $i -eq 5 ]; then
            echo "âŒ Containers are not healthy after 5 attempts"
            echo "Web container: $WEB_STATUS"
            echo "DB container: $DB_STATUS"
            docker-compose -f docker-compose.uat.yml logs web
            docker-compose -f docker-compose.uat.yml logs db
            exit 1
          else
            echo "â³ Waiting for containers to be healthy... ($i/5)"
            sleep 15
          fi
        done
        
        # Run migrations with enhanced retry logic
        echo "ðŸ”„ Running database migrations..."
        for i in {1..5}; do
          # Check if container is still healthy before each attempt
          if docker-compose -f docker-compose.uat.yml ps web | grep -q "restarting"; then
            echo "âš ï¸ Web container is restarting, waiting before retry..."
            sleep 30
            continue
          fi
          
          if docker-compose -f docker-compose.uat.yml exec -T web python manage.py migrate --noinput; then
            echo "âœ… Database migrations completed successfully"
            break
          else
            echo "âŒ Migration attempt $i failed. Retrying in 15 seconds..."
            if [ $i -eq 5 ]; then
              echo "âŒ All migration attempts failed. Checking container logs..."
              docker-compose -f docker-compose.uat.yml logs web
              exit 1
            fi
            sleep 15
          fi
        done
    
    - name: Collect Static Files
      run: |
        # Ensure web container is healthy before collecting static files
        echo "Validating web container health before static files collection..."
        for i in {1..3}; do
          WEB_STATUS=$(docker-compose -f docker-compose.uat.yml ps web | grep -o "Up.*" || echo "Not running")
          
          if echo "$WEB_STATUS" | grep -q "healthy"; then
            echo "âœ… Web container is healthy, proceeding with static files collection"
            break
          elif echo "$WEB_STATUS" | grep -q "restarting"; then
            echo "âš ï¸ Web container is restarting, waiting... ($i/3)"
            sleep 20
          elif [ $i -eq 3 ]; then
            echo "âŒ Web container is not healthy after 3 attempts: $WEB_STATUS"
            docker-compose -f docker-compose.uat.yml logs web
            exit 1
          else
            echo "â³ Waiting for web container to be healthy... ($i/3)"
            sleep 10
          fi
        done
        
        # Collect static files with enhanced retry logic
        echo "ðŸ“ Collecting static files..."
        for i in {1..3}; do
          # Check if container is still healthy before each attempt
          if docker-compose -f docker-compose.uat.yml ps web | grep -q "restarting"; then
            echo "âš ï¸ Web container is restarting, waiting before retry..."
            sleep 20
            continue
          fi
          
          if docker-compose -f docker-compose.uat.yml exec -T web python manage.py collectstatic --noinput; then
            echo "âœ… Static files collected successfully"
            break
          else
            echo "âŒ Static files collection attempt $i failed. Retrying in 10 seconds..."
            if [ $i -eq 3 ]; then
              echo "âŒ All static files collection attempts failed. Checking container logs..."
              docker-compose -f docker-compose.uat.yml logs web
              exit 1
            fi
            sleep 10
          fi
        done
    
    - name: Load Test Data
      run: |
        echo "Loading test data fixtures..."
        docker-compose -f docker-compose.uat.yml exec -T web python manage.py loaddata test_data.json || echo "No test data fixtures found"
    
    - name: Run Integration Tests
      run: |
        echo "Running integration tests..."
        docker-compose -f docker-compose.uat.yml exec -T web python manage.py test --tag=integration --keepdb
    
    - name: Performance Test
      run: |
        echo "Running basic performance tests..."
        # Simple load test
        for i in {1..5}; do
          curl -w "Response time: %{time_total}s\n" -o /dev/null -s http://localhost:8003/
        done
    
    - name: Health Check
      run: |
        echo "Performing comprehensive health check..."
        for i in {1..15}; do
          if curl.exe -f http://localhost:8003/health/; then
            echo "UAT deployment successful!"
            exit 0
          fi
          echo "Attempt $i failed, retrying in 10 seconds..."
          sleep 10
        done
        echo "Health check failed after 15 attempts"
        exit 1
    
    - name: Deployment Notification
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "UAT deployment completed successfully"
          echo "URL: http://uat.educore-lms.com"
          echo "Tag: uat"
          echo "Ready for user acceptance testing"
        else
          echo "UAT deployment failed"
          echo "Consider rollback if necessary"
        fi

  # Deploy to Production (manual approval required)
  # Deploy to Production (after successful UAT deployment)
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build, determine-environment, deploy-uat]
    if: needs.deploy-uat.result == 'success'
    environment:
      name: production
      url: https://educore-lms.com
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Install Docker Compose
      run: |
        sudo curl -L "https://github.com/docker/compose/releases/download/v2.24.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
        sudo chmod +x /usr/local/bin/docker-compose
        docker-compose --version
    
    - name: Pre-deployment Backup
      env:
        DB_NAME: ${{ secrets.DB_NAME || 'educore_db' }}
        DB_USER: ${{ secrets.DB_USER || 'postgres' }}
        DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
      run: |
        echo "Creating comprehensive production backup..."
        echo "Using database: $DB_NAME with user: $DB_USER"
        
        # Check if production services are running
        if ! docker-compose -f docker-compose.prod.yml ps | grep -q "Up"; then
          echo "Starting production services for backup..."
          docker-compose -f docker-compose.prod.yml up -d db
          
          # Wait for database to be ready
          echo "Waiting for database to be ready..."
          for i in {1..30}; do
            if docker-compose -f docker-compose.prod.yml exec -T db pg_isready -U "$DB_USER"; then
              echo "Database is ready"
              break
            fi
            echo "Attempt $i failed, retrying in 5 seconds..."
            sleep 5
          done
        fi
        
        # Create timestamped database backup
        BACKUP_TIME=$(date +%Y%m%d_%H%M%S)
        echo "Creating database backup: backup_prod_${BACKUP_TIME}.sql"
        
        # Set password for pg_dump and create backup
        docker-compose -f docker-compose.prod.yml exec -T -e PGPASSWORD="$DB_PASSWORD" db pg_dump -U "$DB_USER" -d "$DB_NAME" > backup_prod_${BACKUP_TIME}.sql
        
        # Verify backup was created
        if [ -s backup_prod_${BACKUP_TIME}.sql ]; then
          echo "Database backup created successfully ($(wc -l < backup_prod_${BACKUP_TIME}.sql) lines)"
        else
          echo "Database backup failed or is empty"
          exit 1
        fi
        
        # Backup static files and media if they exist
        if [ -d "static" ] || [ -d "media" ]; then
          echo "Creating static files backup..."
          tar -czf static_backup_prod_${BACKUP_TIME}.tar.gz static/ media/ 2>/dev/null || echo "Some static/media directories not found, continuing..."
        fi
        
        # Store backup location for potential rollback
        echo "BACKUP_FILE=backup_prod_${BACKUP_TIME}.sql" >> $GITHUB_ENV
        echo "Backup process completed"
    
    - name: Pre-deployment Validation
      run: |
        echo "Performing pre-deployment validation..."
        # Check current production health
        curl -f http://localhost:8005/health/ || echo "Production health check failed"
        
        # Validate Docker image exists
        docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.determine-environment.outputs.docker_tag }}
    
    - name: Blue-Green Deployment Setup
      run: |
        echo "Setting up blue-green deployment..."
        # Create green environment
        export DOCKER_TAG=${{ needs.determine-environment.outputs.docker_tag }}
        export COMPOSE_PROJECT_NAME=educore_green
        
        # Deploy to green environment on alternate ports
        docker-compose -f docker-compose.green.yml up -d
        
        # Wait for green environment to be ready
        sleep 60
    
    - name: Green Environment Testing
      run: |
        echo "Testing green environment..."
        # Health check on green environment
        for i in {1..10}; do
          if curl.exe -f http://localhost:8001/health/; then
            echo "Green environment is healthy"
            break
          fi
          echo "Attempt $i failed, retrying in 15 seconds..."
          sleep 15
        done
        
        # Run smoke tests
        curl -f http://localhost:8001/api/health/
        curl -f http://localhost:8001/admin/login/
    
    - name: Database Migration (Green)
      run: |
        echo "Running database migrations on green environment..."
        export COMPOSE_PROJECT_NAME=educore_green
        docker-compose -f docker-compose.green.yml exec -T web python manage.py migrate --noinput
    
    - name: Production Deployment (Blue-Green Switch)
      run: |
        echo "Switching to green environment (Production deployment)..."
        echo "Using docker tag: ${{ needs.determine-environment.outputs.docker_tag }}"
        
        # Update production environment
        export DOCKER_TAG=${{ needs.determine-environment.outputs.docker_tag }}
        
        # Graceful shutdown of blue environment
        docker-compose -f docker-compose.prod.yml stop
        
        # Start new production environment
        docker-compose -f docker-compose.prod.yml up -d
        
        # Wait for production to be ready
        sleep 45
    
    - name: Post-deployment Database Tasks
      run: |
        echo "Running post-deployment database tasks..."
        docker-compose -f docker-compose.prod.yml exec -T web python manage.py migrate --noinput
        docker-compose -f docker-compose.prod.yml exec -T web python manage.py collectstatic --noinput
        
        # Clear cache
        docker-compose -f docker-compose.prod.yml exec -T web python manage.py clear_cache || echo "No cache clearing command available"
    
    - name: Production Health Check
      run: |
        echo "Performing comprehensive production health check..."
        for i in {1..20}; do
          if curl.exe -f http://localhost:8005/health/; then
            echo "Production deployment successful!"
            # Clean up green environment
            export COMPOSE_PROJECT_NAME=educore_green
            docker-compose -f docker-compose.green.yml down
            exit 0
          fi
          echo "Attempt $i failed, retrying in 15 seconds..."
          sleep 15
        done
        echo "Production health check failed after 20 attempts"
        exit 1
    
    - name: Production Smoke Tests
      run: |
        echo "Running production smoke tests..."
        # Test critical endpoints
        curl -f http://localhost:8005/api/health/
        curl -f http://localhost:8005/admin/login/
        curl -f http://localhost:8005/courses/
        
        # Test database connectivity
        docker-compose -f docker-compose.prod.yml exec -T web python manage.py check --database default
    
    - name: Deployment Notification
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "PRODUCTION DEPLOYMENT SUCCESSFUL!"
          echo "URL: https://educore-lms.com"
          echo "Tag: ${{ needs.determine-environment.outputs.docker_tag }}"
          echo "Deployed: $(date)"
          echo "All systems operational"
        else
          echo "PRODUCTION DEPLOYMENT FAILED!"
          echo "IMMEDIATE ATTENTION REQUIRED"
          echo "Consider immediate rollback using backup: $BACKUP_FILE"
        fi
    
    - name: Rollback on Failure
      if: failure()
      env:
        DB_NAME: ${{ secrets.DB_NAME || 'educore_db' }}
        DB_USER: ${{ secrets.DB_USER || 'postgres' }}
        DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
      run: |
        echo "Initiating automatic rollback..."
        echo "Using database: $DB_NAME with user: $DB_USER"
        
        # Restore from backup if deployment failed
        docker-compose -f docker-compose.prod.yml down
        
        # Start database service for restore
        docker-compose -f docker-compose.prod.yml up -d db
        
        # Wait for database to be ready
        echo "Waiting for database to be ready for restore..."
        for i in {1..30}; do
          if docker-compose -f docker-compose.prod.yml exec -T db pg_isready -U "$DB_USER"; then
            echo "Database is ready for restore"
            break
          fi
          echo "Attempt $i failed, retrying in 5 seconds..."
          sleep 5
        done
        
        # Restore database
        if [ -f "$BACKUP_FILE" ]; then
          echo "Restoring database from backup: $BACKUP_FILE"
          docker-compose -f docker-compose.prod.yml exec -T -e PGPASSWORD="$DB_PASSWORD" db psql -U "$DB_USER" -d "$DB_NAME" < "$BACKUP_FILE"
          echo "Database restored from backup"
        else
          echo "No backup file found: $BACKUP_FILE"
        fi
        
        # Restart with previous version
        docker-compose -f docker-compose.prod.yml up -d
        echo "Rollback completed - manual verification required"

  # Deploy to Development (fallback environment)
  deploy-development:
    name: Deploy to Development
    runs-on: ubuntu-latest
    needs: [build, determine-environment]
    if: needs.determine-environment.outputs.environment == 'development'
    environment:
      name: development
      url: http://localhost:8004
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Install Docker Compose
      run: |
        sudo curl -L "https://github.com/docker/compose/releases/download/v2.24.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
        sudo chmod +x /usr/local/bin/docker-compose
        docker-compose --version
    
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Create environment file
      run: |
        echo "Creating .env.dev for Development environment"
        
        # Create Development environment .env file
        {
          echo "DJANGO_SETTINGS_MODULE=educore_lms.settings.development"
          echo "SECRET_KEY=${{ secrets.DJANGO_SECRET_KEY }}"
          echo "DATABASE_URL=${{ secrets.DATABASE_URL }}"
          echo "REDIS_URL=${{ secrets.REDIS_URL }}"
          echo "EMAIL_HOST_PASSWORD=${{ secrets.EMAIL_HOST_PASSWORD }}"
          echo "SENTRY_DSN=${{ secrets.SENTRY_DSN }}"
          echo "ENVIRONMENT=development"
          echo "DOCKER_IMAGE_TAG=${{ needs.determine-environment.outputs.docker_tag }}"
          echo "DB_NAME=${{ secrets.DB_NAME }}"
          echo "DB_USER=${{ secrets.DB_USER }}"
          echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}"
          echo "DB_HOST=db"
          echo "DB_PORT=5432"
          echo "ALLOWED_HOSTS=${{ secrets.ALLOWED_HOSTS }}"
          echo "DEBUG=1"
          echo "DJANGO_LOG_LEVEL=DEBUG"
        } > .env.dev

    - name: Deploy to Development
      env:
        REGISTRY: ${{ env.REGISTRY }}
        IMAGE_NAME: ${{ env.IMAGE_NAME }}
        DOCKER_TAG: ${{ needs.determine-environment.outputs.docker_tag }}
      run: |
        echo "Deploying to Development environment (fallback)..."
        echo "Using docker tag: ${{ needs.determine-environment.outputs.docker_tag }}"
        echo "Registry: $REGISTRY"
        echo "Image: $IMAGE_NAME"
        
        # Pull and deploy to development
        docker-compose -f docker-compose.dev.yml pull
        docker-compose -f docker-compose.dev.yml down
        
        docker-compose -f docker-compose.dev.yml up -d
        
        # Wait for services to start
        sleep 30
        
        # Run basic setup
        docker-compose -f docker-compose.dev.yml exec -T web python manage.py migrate --noinput
        docker-compose -f docker-compose.dev.yml exec -T web python manage.py collectstatic --noinput
        
        # Basic health check
        echo "Performing health check..."
         # Wait for services to be ready
         sleep 10
         
         # Check if containers are running
         docker-compose -f docker-compose.dev.yml ps
         
         # Wait for application to be ready
         for i in {1..30}; do
           echo "Waiting for application to be ready... ($i/30)"
           
           # Try direct connection to web container using Python
            if docker-compose -f docker-compose.dev.yml exec -T web python -c "import urllib.request; urllib.request.urlopen('http://localhost:8000/health/')" 2>/dev/null; then
              echo "Health check passed (direct container access)"
              break
            fi
           
           # Try through nginx proxy
           if curl -f http://localhost:8081/health/ 2>/dev/null; then
             echo "Health check passed (nginx proxy)"
             break
           fi
           
           # Try external port access
           if curl -f http://localhost:8004/health/ 2>/dev/null; then
             echo "Health check passed (external port)"
             break
           fi
           
           if [ $i -eq 30 ]; then
             echo "Health check failed after 30 attempts"
             echo "Container status:"
             docker-compose -f docker-compose.dev.yml ps
             echo "Web container logs:"
             docker-compose -f docker-compose.dev.yml logs web
             echo "Nginx container logs:"
             docker-compose -f docker-compose.dev.yml logs nginx
             exit 1
           fi
           sleep 10
         done
        
        echo "Development deployment completed"
        echo "URL: http://localhost:8004"
    
    - name: Create Release
      if: success()
      run: |
        gh release create "v${{ github.run_number }}" \
          --title "Release v${{ github.run_number }}" \
          --notes "Automated release from main branch
        
        **Changes:**
        $COMMIT_MESSAGE
        
        **Docker Image:**
        \`$IMAGE_TAG\`" \
          --latest
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        COMMIT_MESSAGE: ${{ github.event.head_commit.message }}
        IMAGE_TAG: ${{ needs.build.outputs.image-tag }}

  # Notification
  notify:
    name: Notify Teams
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: always()
    
    steps:
    - name: Notify on Success
      if: needs.deploy-production.result == 'success'
      run: |
        echo "Deployment to Production successful!"
        # Add Slack/Teams/Email notification here
    
    - name: Notify on Failure
      if: needs.deploy-production.result == 'failure'
      run: |
        echo "Deployment to Production failed!"
        # Add failure notification here